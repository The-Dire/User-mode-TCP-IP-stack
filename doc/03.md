## 用C语言从零写一个TCP/IP用户态协议栈3：TCP基础知识和三次握手

现在，我们的用户空间TCP/IP协议栈对以太网协议和IP协议的最小实现完成了，现在该探讨可怕的传输控制协议（TCP）了。

TCP在OSI的L4(传输层)上运行，负责修复错误的连接和数据包传递中的错误。实际上，TCP是Internet的主力军，它在当今几乎所有的计算机网络中都提供了可靠的通信。

TCP并非完全是新协议-第一个规范发布于1974年（https://tools.ietf.org/html/rfc675 ）。此后发生了很多变化，TCP进行了许多扩展和更正 （https://tools.ietf.org/html/rfc7414 ）。

这篇文章将深入研究TCP背后的基本理论，并试图为其设计提供动力。此外，我们将研究TCP标头并讨论建立连接（TCP握手）。最后一步，我们将实现网络协议栈中的TCP的第一个功能。

### 文章内容

[可靠性机制](#可靠性机制)

[TCP基础](#TCP基础)

[TCP头格式](#TCP头格式)

[TCP三次握手](#TCP三次握手)

[TCP首部可选项](#TCP首部可选项)

[测试TCP握手](#测试TCP握手)

[结论](#结论)


#### 可靠性机制

可靠发送数据的问题看似肤浅，但涉及其实际实现就变得复杂了。主要是关于数据报式网络中的错误修复出现了几个问题：

+ 发送方等待接收方的确认应等待多长时间？
+ 如果接收方无法像发送数据一样快地处理数据怎么办？
+ 如果介于两者之间的网络（例如路由器）不能像发送数据一样快地处理数据该怎么办？

在几乎所有的网络通信情况下，分组交换网络一定存在潜在的危险-即接收方的确认可能会在传输中损坏甚至丢失，这使发送者处于棘手的情况。

为了解决这些问题，可以使用几种机制。也许最常见的是滑动窗口技术，双方都记下了所传输的数据。窗口数据被认为是顺序的（就像数组的一个切片），并且当数据被双方处理（并确认）时，该窗口会“向前滑动”：

```
                 Left window edge             Right window edge
                       |                             |
                       |                             |
          ---------------------------------------------------------
          ...|    3    |    4    |    5    |    6    |    7    |...
          ---------------------------------------------------------
                  ^     ^                            ^    ^
                  |      \                          /     |
                  |       \                        /      |
             Sent and           Window size: 3         Cannot be
             ACKed                                     sent yet
            
```

使用这种滑动窗的便利特性解决了流量控制的问题。当接收方无法快速处理数据时，需要进行流控制。在这种情况下，滑动窗口的大小将协商为较小，从而导致发送方的输出受到限制。

另一方面，拥塞控制可帮助发送方和接收方之间的网络堆栈不会拥塞。有两种通用方法：在显式版本中，协议具有一个字段，用于专门向发送方通知拥塞状态。在隐式版本中，发送方尝试猜测网络何时拥塞，并应限制其输出。总体而言，拥塞控制是一个复杂且经常发生的网络问题，至今仍在进行伴随研究(https://en.wikipedia.org/wiki/TCP/IP_Illustrated#Volume_1:_The_Protocols )。

### TCP基础

与其他协议（例如UDP和IP）相比，TCP中的基础机制十分复杂。TCP是面向连接的协议，这意味着作为第一步是在恰好的两侧之间建立单播通信信道。然后双方都在积极地维护此连接：建立连接（握手），并告知对方数据状态和可能出现的问题。

TCP的另一个重要属性是它是字节流协议。与UDP不同，TCP不能保证应用程序在发送和接收数据时会产生稳定的数据“块”。相反，TCP实现必须缓冲数据，并且当数据包丢失，重新排序或损坏时，TCP必须等待并在缓冲区中整理数据。仅当数据被认为是完整的时，TCP才能将数据移交给应用程序的套接字。

由于TCP以流的形式对数据进行操作，因此必须将流中的“块”转换为IP可以承载的数据包。这称为打包，其中TCP头包含流中当前索引的序列号。这也是一个保证可靠的属性，可以将流分成许多可变大小的段，然后TCP知道如何重新打包它们。

与IP协议相似，TCP也检查消息的完整性。这可以通过与IP中相同的校验和算法来实现，但是要增加一些细节。主要地，校验和是端到端的，这意味着报头和数据都包括在校验和中。此外，还包括从IP报头构建的伪报头。

如果TCP接收到损坏的段，它将丢弃这些段，并且不通知发送方。该错误由发送方设置的计时器纠正，如果接收方从未确认过该段，则该段计时器可用于重新传输该段。

TCP还是全双工系统，这意味着流量可以同时在两个方向上流动。这意味着通信方必须在存储器中保持双向数据排序。更深入地讲，TCP通过在发送的段中包含对相反流量的确认来保留其流量足迹。

本质上，数据流的排序是TCP的主要原理。但是，保持同步并不是一个简单的问题。

### TCP头格式

接下来，我们将定义TCP的消息首部并描述其字段。TCP首部看似简单，但是包含许多有关通信状态的信息。

TCP首部是由20个八位位组组成的（http://www.tcpdump.org/tcpdump_man.html )：

```
        0                            15                              31
       -----------------------------------------------------------------
       |          source port          |       destination port        |
       -----------------------------------------------------------------
       |                        sequence number                        |
       -----------------------------------------------------------------
       |                     acknowledgment number                     |
       -----------------------------------------------------------------
       |  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |
       -----------------------------------------------------------------
       |         TCP checksum          |       urgent pointer          |
       -----------------------------------------------------------------
```
源端口和目标端口字段用于在主机之间建立多个连接。最初的BSD(伯克利)套接字是应用程序绑定到TCP网络堆栈的常用接口。通过端口，内核根据网络协议栈知道将流量定向到何处。由于这些字段的大小为16位，因此端口值的范围为0到65535。

由于流中的每个字节都已编号，因此序列号(sequence number即seq)代表TCP段的窗口索引。 握手时，它包含初始序列号（ISN）。

确认数字(Acknowledgment Number)包含发送方希望接收的下一个字节的窗口索引。握手后，必须始终填充ACK字段。

首部长度（HL）字段以32位字表示报头的长度。

接下来，是几个标志。 一般不使用前4位（rsvd），rsvd是保留位包含4个未使用的比特位(必须置0)。
下面介绍TCP的几个关键字段。

1. 拥塞窗口(Congestion Window 上图中的C)机制:拥塞窗口的应用有(slow start)慢启动,TCP发送方开始只发一小段数据,当收到了ACK之后,在增加每次发送的数据,直到达到接收方处理能力上限或传输路径的负载能力上线(摸着石头过河机制)。这个是拥塞窗口减小的标记。

2. 显示拥塞通知(ECN Echo上图中的E):用来让发送方收到接收方或传输路径拥塞的通知。

3. 紧急指针(上图中的U):如果设置了该位,那么紧急指针字段包含的信息就是有效的。

4. 确认字符ACK（上图中的A）字段用于传达TCP握手状态。用来表示发来的数据已确认接收无误。在已建立的连接中，它保持打开状态。

5. PSH（P）用于指示接收方应尽快将数据“推送”到应用程序。

6. RST（R）重置TCP连接，用于关闭异常的连接(适用于多种错误情况)。

7. SYN（S）是TCP/IP建立连接时使用的握手信号。用于在初始握手中同步序列号。

8. FIN（F）表示发送方已完成发送数据。用来表明连接已可断开。

“window size”字段用于通告窗口大小。换句话说，这是接收方愿意接受的字节数。由于它是一个16位字段，因此最大窗口大小为65535字节。

TCP校验和(TCP checksum)字段用于验证TCP段的完整性。该算法与Internet协议相同，但是输入段包含TCP数据以及IP数据报中的伪报头。

设置U标志时就会启用紧急指针(urgent pointer)字段。 指针指示紧急数据在流中的位置。

在头部之后的几个字段提供了几个选项。这些选项的一个示例是“最大分段大小”（MSS），其中，发送方将分段的最大大小告知另一端。

在选项字段之后，将显示实际数据。但是，也有不需要数据的情况。例如，握手仅通过TCP头部完成。

tcp头部的声明看tcp.h文件.



```c
struct tcphdr {
    uint16_t sport;
    uint16_t dport;
    uint32_t seq;
    uint32_t ack_seq;
    uint8_t rsvd : 4;
    uint8_t hl : 4;
    uint8_t fin : 1,
            syn : 1,
            rst : 1,
            psh : 1,
            ack : 1,
            urg : 1,
            ece : 1,
            cwr : 1;
    uint16_t win;
    uint16_t csum;
    uint16_t urp;
    uint8_t data[];
} __attribute__((packed));
```



### TCP三次握手

TCP连接通常经历以下阶段：连接建立（握手），数据传输和连接关闭。

下图描述了TCP的常规握手例程：

```
          TCP A                                                TCP B
    	  
    1.  CLOSED                                               LISTEN
    	
    2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED
    	  
    3.  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED
    			
    4.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED
    			  
    5.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED
```
socket（套接字）编程三次握手实现过程:
1. 主机A（客户端）的套接字处于关闭状态，这意味着它不接受连接。相反，绑定到特定端口的主机B（服务端）的套接字正在侦听新连接。

2. 主机A打算启动与主机B的连接。因此，A制作了一个TCP段，该段的SYN标志已设置，并且Sequence字段填充了值（100）。

3. 主机B以设置了SYN和ACK字段的TCP网段作为响应，并通过向其添加1来确认A的序列号（ACK = 101）。同样，B生成序列号（300）。

4. 通过来自连接请求的始发方（A）的ACK，完成3次握手。确认字段反映了主机接下来期望从另一侧接收的序列号。

5. 数据开始传输，主要是因为双方都已经确认了彼此的段号。


这是建立TCP连接的常见方案。 但是，出现了几个问题：

1. 如何选择初始序列号？

2. 如果双方同时要求彼此建立连接怎么办？

3. 如果段延迟了一段时间或无限期会怎样？

初始通信序号（ISN）由通信双方在首次联系时独立选择。由于它是确定连接的关键部分，因此必须对其进行选择，以使其最有可能是唯一的并且不容易猜测。如果初始序列号被捕获的话,TCP序列号攻击是攻击者可以复制TCP连接并有效地将数据馈送到目标，并模拟为受信任主机的情况。

原始规范建议，ISN由一个计数器选择，该计数器每4微秒递增一次。但是，攻击者可以猜测到这一点。 事实上，现代网络协议栈通过更复杂的方法生成ISN。

两个端点彼此接收连接请求（SYN）的情况称为同时打开。这可以通过TCP握手中的额外消息交换来解决：
双方发送一个ACK（不知道对方也这样做了），双方都对请求进行SYN-ACK。此后，数据传输开始。

最后，TCP实现必须有一个计时器，用于知道何时放弃建立连接。尝试重新建立连接，通常采用指数补偿，但是一旦达到最大重试次数或达到时间阈值，该连接被视为不存在。

### TCP首部可选项

TCP首部中的最后一个字段保留用于可能的TCP选项。原始规格提供了三个选项，但后来的规格增加了更多。接下来，我们将介绍最常见的选项。

最大段大小（MSS）选项通知TCP实现愿意接收的最大TCP段大小。在IPv4中，此值的典型值为1460个字节。

选择性确认（SACK）选项可以优化以下情况：发送时丢失许多数据包，并且接收器的数据窗口充满“空包”。为了纠正由此导致的吞吐量下降，TCP实现可以将未通过SACK接收到的特定数据包通知发送方。因此，发送方以累积确认的方案这种更直接的方式接收有关数据状态的信息。

窗口比例(Window Scale option)选项增加了有限的16位窗口尺寸。即，如果双方在其握手段中都包含此选项，则将窗口大小乘以该比例。拥有较大的窗口大小对于批量数据传输而言至关重要。

“时间戳”选项允许发送方将时间戳记放入TCP段中，然后可将其用于计算每个ACK段的RTT。然后，此信息可用于计算TCP重传超时。

### 测试TCP握手

现在，我们已经模拟了TCP握手例程，并且它可以有效侦听每个端口，让我们对其进行测试：

```
[root@localhost ~]$ nmap -Pn 10.0.0.4 -p 1337

Starting Nmap 7.00 ( https://nmap.org ) at 2019-05-08 19:02 EEST
Nmap scan report for 10.0.0.4
Host is up (0.00041s latency).
PORT     STATE SERVICE
1337/tcp open  waste

Nmap done: 1 IP address (1 host up) scanned in 0.05 seconds
```

由于nmap会进行SYN扫描（它仅等待SYN-ACK来确定目标端口是否打开），仅仅通过返回一个SYN-ACK TCP段就很容易以为我们有一个应用程序正在监听端口。

### 结论

只需选择一个序号，设置SYN-ACK标志并计算生成的TCP段的校验和，就可以相对轻松地完成最小可行的TCP握手例程。

下次，我们将研究TCP的最重要职责：可靠的数据传输。 管理滑动窗口对于使用TCP传输数据至关重要，并且其逻辑可能会变得十分复杂。
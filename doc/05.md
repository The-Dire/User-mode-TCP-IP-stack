0## 让我们编写一个TCP/IP堆栈，5:TCP重传

在这一点上，我们有一个TCP/IP协议栈，它能够与Internet上的其他主机通信。到目前为止，实现相当简单，但是缺少一个主要特性:可靠性。

也就是说，我们的TCP不保证它呈现给应用程序的数据流的完整性。如果握手包在传输过程中丢失，即使建立连接也可能失败。

在从头开始创建TCP/IP堆栈时，引入可靠性和控制是我们的一个主要重点。


### 文章内容：

[自动重发请求](#自动重发请求)

[TCP重传机制](#TCP重传机制)

[Karn算法](#Karn算法)

[Jacobson算法](#Jacobson算法)

[超时重传实现细节关键之一:管理RTO计时器](#管理RTO计时器)

[超时重传实现细节关键之二:请求重传](#请求重传)

[测试](#测试)

[结论](#结论)

### 自动重发请求

许多可靠协议的基础是自动重发请求(ARQ)的概念（https://en.wikipedia.org/wiki/Automatic_repeat_request ）。

在ARQ中，接收方对它收到的数据发送确认信息道发送方，发送方如果没有收到确认信息那么它会重新传输它从未收到确认的数据。

正如我们所讨论的，TCP将传输数据的序列号保存在内存中，并反馈确认响应给对接方。于此同时,发送方会将传输的数据放入（备份思想）重传队列，并启动与数据关联的计时器。如果在计时器耗尽之前没有收到对数据序列的确认，则会发生重传。

可以看出，TCP是基于ARQ的原则来构建其可靠性的。TCP也涉及到了ARQ的详细实现。一些简单的问题在这里也变得困难了起来，比如“发送者需要等待多长时间才能收到确认?”这个问题很难回答，尤其是当你想要获得最佳性能的时候。TCP扩展如选择性确认(SACK https://tools.ietf.org/html/rfc2018 )通过确认无序数据和避免不必要的往返来缓解效率问题。

### TCP重传机制

TCP中的重传在RFC文档(https://www.ietf.org/rfc/rfc793.txt  )中描述为:

当TCP传输一个包含数据的段时，它将一个副本放在重传队列上并启动一个计时器;当接收到该数据的确认时，将从队列中删除该段。如果在计时器耗尽之前没有收到确认，则重新传输该段。

但是，计算重传超时的原始公式被认为不适用于不同的网络环境。当前的“标准方法”(https://en.wikipedia.org/wiki/TCP/IP_Illustrated#Volume_1:_The_Protocols )

由Jacobson描述，最新的编码规范可以从RFC6298(https://tools.ietf.org/html/rfc6298 ) 中找到。

基本算法相对简单。对于给定的TCP发送方，定义状态变量来计算超时:

RTT(Round-Trip Time) = 传播时延(往返造成) + 排队时延(路由器和交换机造成) + 数据处理时延(应用程序造成)

- srtt是平滑化的往返时延(Smoothed Round-Trip Time)，用于判断一个段的平均往返时延(RTT)，这里我的理解不太准确可以理解为保持计算简单的情况下尽量考虑历史RTT得出的一个RTT。SRTT = ( ALPHA * SRTT ) + ((1-ALPHA) * RTT)
- rttvar是保存往返时延(RTT)的变量。
- rto是重传时间间隔(retransmission timeout)变量,rto是基于strr计算出来的。RTO = min[UBOUND,max[LBOUND,(BETA*SRTT)]] UBOUND是RTO上限，ALPHA是平滑因子（smoothing factor， e.g., .8 to .9），BETA是一个延迟方差因子（BETA is a delay variance factor (e.g., 1.3 to 2.0)）。

这里对上面两个公式做一个简单的注释：公式1中计算SRTT，ALPHA越接近于0，则表示SRTT越相信这一次的RTT；越接近于1，则表示SRTT越相信上次统计的RTT。公式二给RTO分别设置了一个上限和下限。

### Karn算法

上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和ack回来的时间做RTT样本值，还是用重传的时间和ACK回来的时间做RTT样本值？

这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示：

- 情况（a）是ack没回来，所以重传。如果你计算第一次发送和ACK的时间，那么，明显算大了。
- 情况（b）是ack回来慢了，但是导致了重传，但刚重传不一会儿，之前ACK就回来了。如果你是算重传的时间和ACK回来的时间的差，就会算短了。

为了解决这两个问题诞生了Karn算法，该算法最大的特点是:忽略重传，不把重传的RTT做采样。

这样一来，又会引发一个大BUG——如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的RTO很小），于是，因为重转的不算，所以，RTO就不会被更新，这是一个灾难。 于是Karn算法用了一个取巧的方式——只要一发生重传，就对现有的RTO值翻倍（这就是所谓的 Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的RTT也不靠谱。

采用karn算法的重传实际情况会为:RTO重传间隔是指数增加的。上面我们介绍的是初次重传时的RTO，如果重传后还没收到另一端的响应，下一次重传RTO则会指数增加，例如第一次重传RTO是1，之后分别2，4，8，16...。


### Jacobson算法

如RFC6298所述(即Jacobson / Karels 算法)，计算步骤如下:

1. 第一次RTT测量前:
```
rto = 1000ms
````

2. 第一次RTT测量: 
```
srtt = R
rttvar = R/2
rto = srtt + max(G, 4*rttvar)
```

3. 随后的为了减小误差做的计算:
```
alpha = 0.125
beta = 0.25
rttvar = (1 - beta) * rttvar + beta * abs(srtt - r)
srtt = (1 - alpha) * srtt + alpha * r
rto = srtt + max(g, 4*rttvar)
```

4. 在计算rto之后，如果小于1秒，则四舍五入到1秒。可以指定最大重传时间间隔，但必须大于等于60秒。


注：该简化版本摘自COOLSHELL网站实在感慨大神的总结能力,下面公式是我四步的总结
```
SRTT = SRTT + α (RTT – SRTT)  —— 计算平滑RTT

DevRTT = (1-β)*DevRTT + β*(|RTT-SRTT|) ——计算平滑RTT和真实的差距（加权移动平均）

RTO= µ * SRTT + ∂ *DevRTT —— 神一样的公式
```

（其中：在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”） 最后的这个算法在被用在今天的TCP协议中linux kernel tree的代码 tcp_input.c 可以找到该算法。

传统上估计TCP实现的时钟粒度相当高，从500毫秒到1秒不等。然而，像Linux这样的现代系统使用的时钟粒度是1毫秒。

需要注意的一点是，建议RTO至少保持1秒。这是为了防止虚假的重发，当一个段重发得太快，会导致网络拥塞然后又因为拥塞而重发循环往复。在实践中，许多实现采用亚秒四舍五入:Linux使用200毫秒。

简而言之，srtt是连续RTTs的低通滤波器。而RTT可能存在较大的变化，因此使用rttvar来检测这些变化并防止它们偏离平均函数。

### 管理RTO计时器
管理重新传输计时器相对比较简单。RFC6298推荐以下算法:

1. 当发送数据段而RTO计时器不运行时，使用RTO的超时(timeout)值激活它。
2. 当所有未完成的数据段都被确认后，关闭RTO定时器。
3. 当收到新数据的ACK时，使用RTO值重新启动RTO计时器。

当RTO定时器到期:

1. 转发最早的未确认。
2. 将RTO计时器回退到因数为2的位置，即(RTO = RTO * 2)。
3. 启动RTO计时器。

此外，当取消RTO值并成功地进行后续度量时，RTO值会急剧收缩。当后退并等待确认时，TCP实现可以清除srtt和rttvar。

### 请求重传

TCP通常不仅仅依赖于TCP发送方的计时器来修复丢失的包。接收方还可以通知发送方需要重新传输段。

重复确认是一种算法，在这种算法中，不按顺序的分段被确认，但按最新顺序分段的序号确认。经过三次重复确认之后，TCP发送方应该意识到它需要重新传输重复确认所通知的段。

此外，选择性应答(Selective, SACK)是重复应答的一个更复杂的版本。它是一个TCP选项，在这个选项中，接收方能够将接收到的序列编码到确认中。然后发送方立即注意到任何丢失的段并重新发送它们。具体实现可以参考RFC2883。

### 测试

已经了解了概念和一般算法，可以看看TCP重新传输在网络上是什么样子。

先改变防火墙规则，在连接建立后丢弃数据包，尝试获取Hacker News的首页:

```
$ iptables -I FORWARD --in-interface tap0 \
	-m conntrack --ctstate ESTABLISHED \
	-j DROP
$ ./tools/hf-ip curl news.ycombinator.com
curl: (56) Recv failure: Connection timed out
```

通过观察连接流量，可以看到HTTP GET大约以两倍的间隔被重新传输:

```
[root@localhost ~]$ sudo tcpdump -i tap0 host 10.0.0.4 -n -ttttt
00:00:00.000000 IP 10.0.0.4.41733 > 104.20.44.44.80: Flags [S], seq 3975419138, win 44477, options [mss 1460], length 0
00:00:00.004318 IP 104.20.44.44.80 > 10.0.0.4.41733: Flags [S.], seq 4164704437, ack 3975419139, win 29200, options [mss 1460], length 0
00:00:00.004534 IP 10.0.0.4.41733 > 104.20.44.44.80: Flags [.], ack 1, win 44477, length 0
00:00:00.011039 IP 10.0.0.4.41733 > 104.20.44.44.80: Flags [P.], seq 1:85, ack 1, win 44477, length 84: HTTP: GET / HTTP/1.1
00:00:01.094237 IP 104.20.44.44.80 > 10.0.0.4.41733: Flags [S.], seq 4164704437, ack 3975419139, win 29200, options [mss 1460], length 0
00:00:01.094479 IP 10.0.0.4.41733 > 104.20.44.44.80: Flags [.], ack 1, win 44477, length 0
00:00:01.210787 IP 10.0.0.4.41733 > 104.20.44.44.80: Flags [P.], seq 1:85, ack 1, win 44477, length 84: HTTP: GET / HTTP/1.1
00:00:03.607225 IP 10.0.0.4.41733 > 104.20.44.44.80: Flags [P.], seq 1:85, ack 1, win 44477, length 84: HTTP: GET / HTTP/1.1
00:00:08.399056 IP 10.0.0.4.41733 > 104.20.44.44.80: Flags [P.], seq 1:85, ack 1, win 44477, length 84: HTTP: GET / HTTP/1.1
00:00:18.002415 IP 10.0.0.4.41733 > 104.20.44.44.80: Flags [P.], seq 1:85, ack 1, win 44477, length 84: HTTP: GET / HTTP/1.1
00:00:37.289491 IP 10.0.0.4.41733 > 104.20.44.44.80: Flags [P.], seq 1:85, ack 1, win 44477, length 84: HTTP: GET / HTTP/1.1
00:01:15.656151 IP 10.0.0.4.41733 > 104.20.44.44.80: Flags [P.], seq 1:85, ack 1, win 44477, length 84: HTTP: GET / HTTP/1.1
00:02:32.590664 IP 10.0.0.4.41733 > 104.20.44.44.80: Flags [P.], seq 1:85, ack 1, win 44477, length 84: HTTP: GET / HTTP/1.1
```

验证重传和接收重传数据包是很容易的，但是当仅为某些段触发重传时，情况又会如何呢?为了获得最佳性能，当检测到连接为健康连接时，RTO算法需要“反弹”。

将防火墙规则设置为只阻塞第6个包，大小为6000字节:

```
$ iptables -I FORWARD --in-interface tap0 \
	-m connbytes --connbytes 6 \
	--connbytes-dir original --connbytes-mode packets \
	-m quota --quota 6000 -j DROP
```

现在，如果试图发送一些数据，我们的TCP必须识别通信中断和它何时结束。发送6009个字节发生如下情况:

```
$ ./tools/hf-ip curl -X POST http://httpbin.org/post \
	-d "payload=$(perl -e "print 'lorem ipsum ' x500")"
```

逐步了解连接阶段，看看何时触发重传以及RTO值如何更改。下面是一个修改后的tcpdump输出与我们的TCP套接字的内部状态以及对现象的注释:

```
00.000000 10.0.0.4.49951 > httpbin.org.80: [S], seq 1, options [mss 1460]
00.120709 httpbin.org.80 > 10.0.0.4.49951: [S.], seq 1, ack 1, options [mss 8961]
00.120951 10.0.0.4.49951 > httpbin.org.80: [.], ack 1

- 连接建立后，10.0.0.4:49951的TCP RTO值为1000毫秒。

00.122686 10.0.0.4.49951 > httpbin.org.80: [P.], seq 1:174, ack 1: POST /post
00.242564 httpbin.org.80 > 10.0.0.4.49951: [.], ack 174
01.141287 10.0.0.4.49951 > httpbin.org.80: [.], seq 174:1634, ack 1: HTTP
01.141386 10.0.0.4.49951 > httpbin.org.80: [.], seq 1634:3094, ack 1: HTTP
01.141460 10.0.0.4.49951 > httpbin.org.80: [.], seq 3094:4554, ack 1: HTTP
01.263301 httpbin.org.80 > 10.0.0.4.49951: [.], ack 1634
01.265995 httpbin.org.80 > 10.0.0.4.49951: [.], ack 3094

- 到目前为止,远程主机已经对我们的HTTP POST和负载(payload)开始进行了攻击。此时RTO值为336ms。

01.526797 10.0.0.4.49951 > httpbin.org.80: [.], seq 3094:4554, ack 1: HTTP
02.259425 10.0.0.4.49951 > httpbin.org.80: [.], seq 3094:4554, ack 1: HTTP
03.735553 10.0.0.4.49951 > httpbin.org.80: [.], seq 3094:4554, ack 1: HTTP

- 由iptables规则引起的通信中断已经开始。
    我们的TCP必须重新传输段多次。
    套接字的RTO值不断增加:
        01.526797:618毫秒
        02.259425:1236毫秒
        03.735553:2472毫秒

06.692867 10.0.0.4.49951 > httpbin.org.80: [.], seq 3094:4554, ack 1: HTTP
06.819115 httpbin.org.80 > 10.0.0.4.49951: [.], ack 4554

- 最后，远程主机响应。我们的RTO值已经增加到4944ms。Karn算法在这里生效:新的RTO值不能用重新传输的段来测量，所以我们跳过它。

06.819356 10.0.0.4.49951 > httpbin.org.80: [.], seq 4554:6014, ack 1: HTTP
06.819442 10.0.0.4.49951 > httpbin.org.80: [P.], seq 6014:6182, ack 1: HTTP
06.948678 httpbin.org.80 > 10.0.0.4.49951: [.], ack 6014
06.948917 httpbin.org.80 > 10.0.0.4.49951: [.], ack 6182

- 现在，我们第一次尝试就得到了回报，网络又恢复了健康。Karn算法允许我们测量新的RTO:
    06.948678:309毫秒
    06.948917:309毫秒
  
06.948942 httpbin.org.80 > 10.0.0.4.49951: [P.], seq 1:26, ack 6182: HTTP 100 Continue
06.949014 httpbin.org.80 > 10.0.0.4.49951: [.], seq 26:1486, ack 6182: HTTP/1.1 200 OK
06.949145 10.0.0.4.49951 > httpbin.org.80: [.], ack 26
06.949816 httpbin.org.80 > 10.0.0.4.49951: [.], seq 1486:2946, ack 6182: HTTP
06.949894 httpbin.org.80 > 10.0.0.4.49951: [.], seq 2946:4406, ack 6182: HTTP
06.950029 10.0.0.4.49951 > httpbin.org.80: [.], ack 2946
06.950030 httpbin.org.80 > 10.0.0.4.49951: [.], seq 4406:5866, ack 6182: HTTP
06.950161 httpbin.org.80 > 10.0.0.4.49951: [P.], seq 5866:6829, ack 6182: HTTP
06.950287 10.0.0.4.49951 > httpbin.org.80: [.], ack 5866
06.950435 10.0.0.4.49951 > httpbin.org.80: [.], ack 6829
06.958155 10.0.0.4.49951 > httpbin.org.80: [F.], seq 6182, ack 6829
07.082998 httpbin.org.80 > 10.0.0.4.49951: [F.], seq 6829, ack 6183
07.083253 10.0.0.4.49951 > httpbin.org.80: [.], ack 6830

- 数据通信和连接完成。
    RTO测量没有发生重大变化。
```

### 结论

TCP中的重传是健壮实现的重要组成部分。TCP必须能够在不断变化的网络环境中生存和执行，例如，在这些环境中，延迟可能突然出现峰值，或者网络路径暂时被阻塞。

下一次，我们将研究TCP拥塞控制，以在不降低网络健康状况的情况下获得最大的性能。


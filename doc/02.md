## 用C语言从零写一个TCP/IP用户态协议栈2：IPV4&ICMPv4

这次，在用户空间TCP/IP协议栈中，我们将实现一个最小可行的IP层，并使用ICMP回显请求（也称为ping）对其进行测试。

我们将看一下IPv4和ICMPv4的格式，并描述如何检查它们的完整性。 一些功能（例如IP碎片处理）还未做。

对于我们的网络堆栈，选择IPv4而不是IPv6，因为它仍然是Internet的默认网络协议。但是，这种情况正在快速改变，将来我们的网络协议栈可以使用IPv6进行扩展。



### 文章内容：

[IPv4网络协议](#IPv4网络协议)
- [IP报文头结构](#IP报文头结构)
- [IP包的校验](#IP校验和)

[ICMP网络控制协议](#ICMP网络控制协议)
- [ICMP报文头结构](#ICMP报文头结构)
- [ICMP消息的接收与处理](#ICMP消息的接收与处理)

[实现测试](#实现测试)

[结论](#结论)

### IPv4网络协议

在我们实现中的下一层（L3网络层IP层)，在以太网帧之后，负责将数据传送到目的地。这一层的核心:Internet协议（IP）的发明是为TCP和UDP等传输协议提供了基础。

它是无连接的，这意味着与TCP不同，所有数据报在网络堆栈中都是彼此独立处理的。 这也意味着IP数据报可能会无序到达。

​在我们的实现中，IP报文经过以太帧封装后，会将数据传输给目的地。IP网络协议是基于TCP/UDP传输协议发明的，它不像TCP协议那样所有的数据都是通过网络栈来处理的，IP协议是无连接的，因此IP数据可能会有不可达的情况。

​IP协议不保证成功传输，这是设计者故意设计成这样的，因为IP是提供一个基于传输协议的封装，如IP基于UDP，那么传输不能保证对端一定能收到；如果你想要传输是可信的，那么选择IP基于TCP，TCP协议能够处理丢包并且能确保所有报文都能够成功传输。

#### IP报文头结构

IPv4头结构一般20个字节。头结构中还可以包含可选选项，但是我们的实现将它省略，IPv4报文头结构可以用以下C语言结构表示：

```c
struct iphdr {
    uint8_t version : 4;
    uint8_t ihl : 4;
    uint8_t tos;
    uint16_t len;
    uint16_t id;
    uint16_t flags : 3;
    uint16_t frag_offset : 13;
    uint8_t ttl;
    uint8_t proto;
    uint16_t csum;
    uint32_t saddr;
    uint32_t daddr;
} __attribute__((packed));
```

4-bit的version字段表示我们IP的版本，我们的实现这个字段是4，表示IPv4

Internet标头长度字段ihl同样是4位长度，它表示IP标头中32位字的数量。由于该字段的大小为4位，因此只能保留最大值15。因此，IP标头的最大长度为60个八位位组（15乘以32除以8）。

服务字段的类型源自首个IP规范（http://tools.ietf.org/html/rfc791 ）。在以后的规范中，它被划分为较小的字段，但为简单起见，我们将按原始规范中的定义来处理该字段。该字段传达旨在用于IP数据报的服务质量。

总长度字段len传达整个IP数据报的长度。由于它是一个16位字段，因此最大长度为65535字节。大型IP数据报会受到分段的影响，在分段中，它们会拆分成较小的数据报，以满足不同通信接口的最大传输单元（MTU）。

id字段用于索引数据报，并最终用于重组分段的IP数据报。该字段的值只是发送方增加的计数器。反过来，接收方知道如何排序传入的片段。

flags字段定义数据报的各种控制标志。具体来说，发送方可以指定是否允许对数据报进行分段，是最后一个分段还是有更多分段进入。

片段偏移字段frag_offset指示片段在数据报中的位置。自然，第一个数据报的索引设置为0。

ttl生存时间是一个常用属性，用于计时数据报的生命周期。通常，原始发送者将其设置为64，每个接收者将该计数器减1。当它达到零时，数据报将被丢弃，并且可能会回复ICMP消息以指示错误。

proto字段为数据报提供了在其有效载荷中携带其他协议的固有能力。该字段通常包含16（UDP）或6（TCP）之类的值，并且仅用于将实际数据的类型传达给接收器。

标头校验和字段csum用于验证IP标头的完整性。它的算法相对简单，并将在后文中进一步解释。

最后，saddr和daddr字段分别指示数据报的源地址和目标地址。这些字段的长度为32位，可以计算得出提供了大约45亿个地址的池，ipv4地址范围将在不久的将来耗尽。IPv6协议将此长度扩展到128位，将来可能会永久验证Internet协议的地址范围。

#### IP校验和

IP校验和(csum)字段用于检查IP数据报的完整性。计算校验和相对简单，并且在原始规范中定义(http://tools.ietf.org/html/rfc791)：

计算方法如下：

为了计算一份数据报的IP检验和，首先把检验和字段置为0。然后，对首部中每个16bit进行二进制反码求和（整个首部看成是由一串16bit的字组成），结果存在检验和字段中。当收到一份IP数据报后，同样对首部中每个16bit进行二进制反码的求和。由于接受方在计算过程中包含了发送方存在首部中的校验和。因此，如果首部在传输过程中没有发生任何差错，那么接受方计算的结果应该为全1。如果结果不是全1（即检验和错误），那么IP就丢弃收到的数据报。

该算法的实际代码如下(https://tools.ietf.org/html/rfc1071 )：

```C
uint16_t checksum(void *addr, int count)
{
    /* Compute Internet Checksum for "count" bytes
     *         beginning at location "addr".
     * Taken from https://tools.ietf.org/html/rfc1071
     */

    register uint32_t sum = 0;
    uint16_t * ptr = addr;

    while( count > 1 )  {
        /*  This is the inner loop */
        sum += * ptr++;
        count -= 2;
    }

    /*  Add left-over byte, if any */
    if( count > 0 )
        sum += * (uint8_t *) ptr;

    /*  Fold 32-bit sum to 16 bits */
    while (sum>>16)
        sum = (sum & 0xffff) + (sum >> 16);

    return ~sum;
}
```

假设为20字节的消息:
以IP头为12 34  56 78  9A BC  DE F0  12 34  00 00  9A BC  DE F0  12 34  56 78为例：

```
1. 其中校验和部分被暂时先置为00 00。把这部分字节流按每两个字节为一单元分割，然后对分割后的所有两字节数进行二进制求和： `0x1234 + 0x5678 + 0x9ABC + 0xDEF0 + 0x1234 + 0x0000 + 0x9ABC +0xDEF0 + 0x1234 + 0x5678` 。
2. 按照32位数的加法得到0x3D6E4, 但我们的校验和是16位的，需要持续把这个结果的高16位加回到低16位，直到高16位为0，我们再次计算 `0x0003 ＋ 0xD6E4`。
3. 得到结果为0xD6E7。这次高16位已经为0了。最后我们对0xD6E7按位取反，`1101 0110 1110 0111  ->  0010 1001 0001 1000` 。
4. 得到校验和 ＝ ~0xDE67 = 0x2918。最后我们发送的IP头部字节流为： `12 34  56 78  9A BC  DE F0  12 34  29 18  9A BC  DE F0  12 34  56 78`
5. 接收方收到IP头部后，依旧把这部分消息按每两个字节为一单元分割，同样再对分割后的所有二字节数（包括校验和自身所在的字节）进行二进制求和。这个时候计算`0x1234 + 0x5678 + 0x9ABC + 0xDEF0 + 0x1234 + 0x2918 + 0x9ABC +0xDEF0 + 0x1234 + 0x5678
`
6. 得到结果为0x3FFFC，继续计算`0x0003 + 0xFFFC`

得到0xFFFF，即所有位数都是1，这也是-0的one's complement。

可以再次应用算法来验证校验和，如果结果为0注意return的是~0所以函数返回的结果为全1，数据很有可能是好的。
```
ip协议的代码主要集中在ip.h , ip_input.c, ip_output.c中。其中icmp协议和tcp协议都需要ip协议。而ip需要封装成Ethernet


### ICMP网络控制协议

由于IP协议缺乏可靠性机制，因此需要某种方式向通信方通知可能的错误情况。Internet控制消息协议（ICMP）（https://www.ietf.org/rfc/rfc792.txt ）被用于网络中的诊断措施。举个例子当网关不可访问的情况，ICMP协议就-识别出此网关的网络协议栈并通过ICMP协议将“网关无法访问”消息发送回源。


#### ICMP报文头结构

ICMP报头驻留在相应IP数据包的有效负载(payload)中。 ICMPv4头的结构如下：
```C
struct icmp_v4 {
    uint8_t type;
    uint8_t code;
    uint16_t csum;
    uint8_t data[];
} __attribute__((packed));
```
在这里，type字段即消息类型字段用来传达该消息的目的。为type字段保留了42个不同的值(http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml )，但通常仅使用大约8个。在我们的实现中，使用类型0（回声应答），3（目标不可达）和8（回声请求)。

code字段进一步描述了消息的含义。例如，当类型为3（目标无法到达）时，代码字段将说明原因。常见错误是无法将数据包路由到网络时：然后，发起主机很可能会收到类型为3且代码为0（Net Unreachable）的ICMP消息。

#### ICMP消息的接收与处理

实际的ICMP有效负载（payload）包括查询消息,信息消息和错误消息。首先，我们来看看Echo Request/Reply消息(如果你没写过echo request/reply服务器建议实现一下很简单)，在网络中通常称为“ ping”：

```C
struct icmp_v4_echo {
    uint16_t id;
    uint16_t seq;
    uint8_t data[];
} __attribute__((packed));
```
消息格式十分紧凑(节省空间)。字段id由发送主机设置，以确定echo reply（回复)打算用于哪个进程。例如，可以在该字段中设置进程id,告知是用于那个进程。

字段seq是echo(echo回声可以理解为远端进程通知主机接收到你的消息的通知)的序号，它只是一个从零开始并且每当形成新的echo请求时就递增1的数字。这用于检测回显消息在传输过程中是否消失或是否重新排序。

data字段是可选的，但通常包含诸如echo的时间戳之类的信息。然后可以将其用于估计主机之间的往返时间。

可能最常见的ICMPv4错误消息比如“目的地不可达”的ICMP数据结构有以下格式：
```C
struct icmp_v4_dst_unreachable {
    uint8_t unused;
    uint8_t len;
    uint16_t var;
    uint8_t data[];
} __attribute__((packed));
```
第一个八位未使用。然后，len字段表示原始数据报的长度，以IPv4的4字节为单位。2个字节的字段var的值取决于ICMP代码。

最后，将导致“目标无法到达”状态的原始IP数据包尽可能多地放入data字段中。

### 实现测试
从shell中，我们可以验证我们的用户空间网络协议栈是否响应了ICMP回显请求：

```bash
ping -c3 10.0.0.4
# 输出
PING 10.0.0.4 (10.0.0.4) 56(84) bytes of data.
64 bytes from 10.0.0.4: icmp_seq=1 ttl=64 time=0.191 ms
64 bytes from 10.0.0.4: icmp_seq=2 ttl=64 time=0.200 ms
64 bytes from 10.0.0.4: icmp_seq=3 ttl=64 time=0.150 ms

--- 10.0.0.4 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 1999ms
rtt min/avg/max/mdev = 0.150/0.180/0.200/0.024 ms
```

### 结论

有了这些数据结构就可以相对容易地创建并处理以太网帧，ARP和IP的最小可行网络协议栈也就实现了。但是，原始规格已扩展为许多新规格。在本文中，我们浏览了IP功能，例如选项，分段以及标的DCN字段和DS字段。

此外，IPv6对于Internet的未来至关重要。它尚未普及，但它是比IPv4更新的协议，它绝对是应在我们的网络协议栈中实现的协议(这里没有实现)。

可以在GitHub上找到此博客文章的源代码。

在下一个文章中，我们将前进到传输层（L4）并开始实现"名声显赫的保守党"的传输控制协议（TCP）。TCP是面向连接的协议，并且确保两个通信侧之间的可靠性。这些方面显然带来了更多的复杂性，而TCP作为一种旧协议，则有其十分蹩脚的角落。如果你看过TCP/IP详解你就会知道为什么它会有蹩脚的一面，以及也许不这么设计会更加蹩脚。

欢迎你关注我的微博 https://weibo.com/u/6082305003 走进我的生活。